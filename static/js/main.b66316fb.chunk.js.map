{"version":3,"sources":["pathFindingProject/Node/Node.js","ALgorithms/dijkstra.js","ALgorithms/dfs.js","pathFindingProject/pathFindingProject.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","isfinish","isstart","iswall","onMouseDown","onMouseEnter","onMouseUp","tempstart","tempfinish","row","col","ispath","animatevisited","extraclassname","isinstack","id","className","Component","dijkstra","grid","startnode","finishnode","visitedNodes","distance","unvisitednodes","nodes","push","getAllNodes","length","sortunvisitednodes","minDistanceNode","shift","isvisited","Infinity","unvisitedNeighbours","getNeighbours","neighbourNode","prevnode","node","neighbours","sort","nodeA","nodeB","getpath","path","currnode","unshift","console","log","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","pathFindingProject","state","mouseIsPressed","startpressed","finishpressed","i","children","j","createNode","setState","visitednodes","animateDijkstra","newgrid","slice","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setInterval","document","getElementById","colgird","newNode","visitedNodesInOrder","setTimeout","animateShortestPath","coloredvisitedgrid","newnode","visitednodedfs","que","neighbournode","dfs","animatedfs","onClick","visualizeDijkstra","visualizedfs","map","rowindx","key","colindx","handleMouseDown","handleMouseEnter","handleMouseUp","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b66316fb.chunk.js","sourcesContent":["import React ,{Component}from 'react';\r\nimport './Node.css'\r\nclass Node extends Component{\r\n   \r\n    render(){\r\n        const {isfinish,isstart,iswall,onMouseDown,onMouseEnter,onMouseUp,tempstart,tempfinish,row,col,ispath,animatevisited,isinstack}=this.props;\r\n       // const extraclassname=isfinish?'finishnode':isstart?'startnode':'';\r\n       var extraclassname='';\r\n      \r\n       if(iswall){\r\n           extraclassname='wall';\r\n       }\r\n       \r\n       if(animatevisited){\r\n           extraclassname='visited-node';\r\n       }\r\n      \r\n       if(ispath){\r\n        extraclassname='path-node';\r\n    }\r\n    //i added tempstart and tempfinish to add color to nodes when we move start and finish node\r\n    //but these nodes are not final start and finish \r\n    //they just add colors so we can visualize their movements\r\n    else if(isstart||tempstart){\r\n        extraclassname='startnode';\r\n    }\r\n    if(isfinish||tempfinish)\r\n    extraclassname='finishnode';\r\n    if(tempstart)\r\n    extraclassname='startnode';\r\n\r\n   \r\n        return(\r\n            <div\r\n            id={`node-${row}-${col}`} \r\n            className={`node ${extraclassname}`}\r\n            ///on mousedown we are calling the function onMouseDown(row,col) of pathindingproject.js thats why \r\n            //i have used them as a props\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row,col)} ></div>\r\n        )\r\n    }\r\n    \r\n}\r\nexport default Node;","import React from 'react';\r\n \r\n\r\n\r\nexport function dijkstra(grid,startnode,finishnode){\r\n    const visitedNodes=[];\r\n    startnode.distance=0;\r\n    const unvisitednodes=getAllNodes(grid);\r\n    while(unvisitednodes.length>0){\r\n        sortunvisitednodes(unvisitednodes);\r\n       const minDistanceNode=unvisitednodes.shift()//these will return the first element in the array\r\n       if(minDistanceNode.isvisited)\r\n       continue;\r\n       if(minDistanceNode.iswall)\r\n       continue;\r\n       if(minDistanceNode.distance===Infinity)\r\n       return visitedNodes;\r\n       minDistanceNode.isvisited=true;\r\n        visitedNodes.push(minDistanceNode);\r\n        if(minDistanceNode===finishnode){\r\n            return visitedNodes;\r\n        }\r\n        const unvisitedNeighbours=getNeighbours(grid,minDistanceNode);\r\n        for(const neighbourNode of unvisitedNeighbours){\r\n                neighbourNode.distance=minDistanceNode.distance+1;\r\n                neighbourNode.prevnode=minDistanceNode;\r\n        }\r\n    }\r\n}\r\nfunction getNeighbours(grid,node){\r\n    const neighbours=[];\r\n    const row=node.row;\r\n    const col=node.col;\r\n    if(node.row>0){\r\n        if(!grid[row-1][col].isvisited)\r\n        neighbours.push(grid[row-1][node.col]);\r\n        /*\r\n        /////only for diagonal movements\r\n        if(col>0)\r\n        if(!grid[row-1][col-1].isvisited){\r\n            neighbours.push(grid[row-1][col-1]);\r\n        }\r\n        if(col<grid[0].length-1){\r\n            if(!grid[row-1][col+1].isvisited){\r\n                neighbours.push(grid[row-1][col+1])\r\n            }\r\n        }*/\r\n    }\r\n    if(node.row<grid.length-1){\r\n        if(!grid[row+1][col].isvisited)\r\n        neighbours.push(grid[row+1][col]);\r\n        /*\r\n        //////////////only for diagonal movements\r\n        if(col>0)\r\n        if(!grid[row+1][col-1].isvisited){\r\n            neighbours.push(grid[row+1][col-1]);\r\n        }\r\n        if(col<grid[0].length-1){\r\n            if(!grid[row+1][col+1].isvisited){\r\n                neighbours.push(grid[row+1][col+1])\r\n            }\r\n        }\r\n        */\r\n    }\r\n    if(col>0){\r\n        if(!grid[row][col-1].isvisited)\r\n        neighbours.push(grid[row][col-1]);\r\n    }\r\n    if(col<grid[0].length-1){\r\n        if(!grid[row][col+1].isvisited){\r\n            neighbours.push(grid[row][col+1]);\r\n        }\r\n    }\r\n    return neighbours;\r\n}\r\nfunction sortunvisitednodes(unvisitednodes){\r\n    unvisitednodes.sort((nodeA,nodeB)=>nodeA.distance-nodeB.distance);\r\n}\r\nfunction getAllNodes(grid){\r\n    const nodes=[];\r\n   for(const row of grid){\r\n       for(const col of row){\r\n           nodes.push(col);\r\n       }\r\n   }\r\n    return nodes;\r\n}\r\nexport  function getpath(finishnode){\r\n    const path=[];\r\n    let currnode=finishnode;\r\n    while(currnode!=null){\r\n        path.unshift(currnode);\r\n        currnode=currnode.prevnode;\r\n    }\r\n    return path;\r\n}","export function dfs(grid,startnode,finishnode){\r\n    const visitednodes=[];\r\n    const que=[];\r\n    que.push(startnode);\r\n    while(que.length>0){\r\n        console.log(\"que length \"+que.length);\r\n        //const node=que.shift();\r\n        let i=que.length-1;\r\n        ////using these while loop i am making sure that i will get the last node that has not been in the stack\r\n        ////i used these hacky method because implementing another class named stack and then creating its object here\r\n        ///is tedius for me because i want only pop method which i am able to do these here using while loop\r\n        while(que[i].isinstack){\r\n            i--;\r\n        }\r\n        if(i==-1)\r\n        return visitednodes;\r\n        const node=que[i];\r\n        node.isinstack=true;\r\n        if(node.iswall)\r\n        continue;\r\n        visitednodes.push(node);\r\n        console.log(node);\r\n        if(node.isvisited)\r\n        continue;\r\n        node.isvisited=true;\r\n   const neighbours=getNeighbours(grid,node);\r\n    for(const neighbournode of neighbours){\r\n        console.log(\"hello\");\r\n        neighbournode.prevnode=node;\r\n        if(neighbournode.row===finishnode.row&&neighbournode.col===finishnode.col)\r\n        return visitednodes;\r\n        else{\r\n           \r\n            que.push(neighbournode);\r\n        }\r\n    }\r\n}\r\n        return visitednodes;\r\n}\r\n////these is the recursive algo of dfs just for reference\r\n/*public static void dfs(int u, ArrayList<Integer> list[], boolean  vis[]){\r\n    for(int i:list[u]){\r\n        if(!vis[i]){\r\n            vis[i]=true;\r\n            dfs(i,list,vis);\r\n        }\r\n    }\r\n}*/\r\n//////not considering the diagonal paths or nodes\r\n////////code for diagonal nodes is written in dijkstra.js getNeighbours functon for reference\r\nfunction getNeighbours(grid,node){\r\n    const neighbours=[];\r\n    const row=node.row;\r\n    const col=node.col;\r\n    if(node.row>0){\r\n        if(!grid[row-1][col].isvisited){\r\n        neighbours.push(grid[row-1][node.col]);\r\n        console.log(node.row);\r\n        }\r\n    }\r\n    if(node.row<grid.length-1){\r\n        if(!grid[row+1][col].isvisited){\r\n        neighbours.push(grid[row+1][col]);\r\n        console.log(node.row);\r\n        }\r\n    }\r\n    if(col>0){\r\n        console.log(node)\r\n        if(!grid[row][col-1].isvisited){\r\n        neighbours.push(grid[row][col-1]);\r\n        console.log(node.row);\r\n    }\r\n    }\r\n    if(col<grid[0].length-1){\r\n        if(!grid[row][col+1].isvisited){\r\n            neighbours.push(grid[row][col+1]);\r\n            console.log(node.row);\r\n        }\r\n    }\r\n    return neighbours;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./pathFindingProject.css\";\r\nimport {dijkstra,getpath} from \"../ALgorithms/dijkstra\"\r\nimport {dfs} from \"../ALgorithms/dfs\"\r\n////at first i made these 4 const but since i want to move these nodes i have made them variables\r\nlet START_NODE_ROW=10;\r\nlet START_NODE_COL=15;\r\nlet FINISH_NODE_ROW=10;\r\nlet FINISH_NODE_COL=40;\r\nclass pathFindingProject extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodes: [],\r\n      mouseIsPressed: false,\r\n      ///i added startpressed and finishpressed to change their locations\r\n      startpressed:false,\r\n      finishpressed:false,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    const nodes = [];\r\n    for (let i = 0; i < 16; i++) {\r\n      const children = [];\r\n      for (let j = 0; j < 49; j++) {\r\n        children.push(createNode(i,j));\r\n      }\r\n      nodes.push(children);\r\n    }\r\n    this.setState({ nodes:nodes });\r\n  }\r\n  visualizeDijkstra(){\r\n    console.log(\"vd called\");\r\n      const {nodes}=this.state;\r\n      const startnode=nodes[START_NODE_ROW][START_NODE_COL];\r\n      const finishnode=nodes[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const visitednodes=dijkstra(nodes,startnode,finishnode);\r\n      const path=getpath(finishnode);\r\n     this.animateDijkstra(visitednodes,path);\r\n     \r\n  }\r\n  handleMouseDown(row, col) {\r\n    console.log(this.state);\r\n    if(row===START_NODE_ROW&&col===START_NODE_COL){\r\n      this.setState({startpressed:true});\r\n     // const newGrid=getNewGridWithStartingPosition()\r\n      const {nodes}= this.state;\r\n      const newgrid=nodes.slice();\r\n      const node=newgrid[row][col];\r\n      node.isstart=false;\r\n      newgrid[row][col]=node;\r\n      this.setState({nodes:newgrid})\r\n      \r\n    }\r\n    else if(row===FINISH_NODE_ROW&&col===FINISH_NODE_COL){\r\n      this.setState({finishpressed:true});\r\n      const {nodes}=this.state;\r\n      const newgrid=nodes.slice();\r\n      const node=newgrid[row][col];\r\n      node.isfinish=false;\r\n      newgrid[row][col]=node;\r\n      this.setState({nodes:newgrid});\r\n    }\r\n    else{\r\n      const {startpressed,finishpressed}=this.state;\r\n      ////i am doing these to visualize the movement of start and finish nodes\r\n      ////but these is not working god knows why already 1 hr wasted finding these bug\r\n      if(startpressed===true){\r\n        console.log(\"startpressed\");\r\n          const {nodes}=this.state;\r\n          const newgrid=nodes.slice();\r\n          const node=newgrid[row][col];\r\n          node.tempstart=true;\r\n          newgrid[row][col]=node;\r\n          this.setState({nodes:newgrid});\r\n      }\r\n      else if(finishpressed===true){\r\n        const {nodes}=this.state;\r\n        const newgrid=nodes.slice();\r\n        const node=newgrid[row][col];\r\n        node.tempfinish=true;\r\n        newgrid[row][col]=node;\r\n        this.setState({nodes:newgrid});\r\n      }\r\n      else{\r\n    const newGrid = getNewGridWithWallToggled(this.state.nodes, row, col);\r\n    this.setState({nodes: newGrid, mouseIsPressed: true});\r\n      }\r\n    }\r\n  }\r\n  handleMouseUp(row,col) {\r\n    this.setState({mouseIsPressed: false});\r\n    const {startpressed}=this.state;\r\n    const {finishpressed}=this.state;\r\n    ////////when we lift up the mouse then that will be the start pos\r\n    if(startpressed===true){\r\n      const {nodes}=this.state;\r\n      const newgrid=nodes.slice();\r\n      const node=newgrid[row][col];\r\n      node.isstart=true;\r\n      newgrid[row][col]=node;\r\n      START_NODE_ROW=row;\r\n      START_NODE_COL=col;\r\n      this.setState({nodes:newgrid,startpressed:false});\r\n    }\r\n    else if(finishpressed){\r\n      const {nodes}=this.state;\r\n      const newgrid=nodes.slice();\r\n      const node=newgrid[row][col];\r\n      node.isfinish=true;\r\n      newgrid[row][col]=node;\r\n      FINISH_NODE_ROW=row;\r\n      FINISH_NODE_COL=col;\r\n      this.setState({nodes:newgrid,finishpressed:false});\r\n    }\r\n  }\r\n  handleMouseEnter(row, col) {\r\n    //console.log(\"called\");\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.nodes, row, col);\r\n    this.setState({nodes: newGrid});\r\n    //this.setState({mouseIsPressed:false});\r\n  }\r\n \r\n \r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      \r\n      const node=nodesInShortestPathOrder[i];\r\n      setInterval(() => {\r\n        ///i am not using these method because in these every 20ms the state gets updated and \r\n        // and hence every time whole grid gets lodded that leads lot of lags\r\n        //that is why i used DOM method of js to find the element by id and to give every node a unique id\r\n        //i have given every node an id refer Node.js that consists of row and col\r\n       // const pathgrid=this.getcoloredpath(this.state.nodes,node.row,node.col);\r\n        //this.setState({nodes: pathgrid});\r\n       \r\n        document.getElementById(`node-${node.row}-${node.col}`).className= 'node path-node'\r\n      }, 20*i);\r\n    \r\n    }\r\n  }\r\n  getcoloredpath(nodes,row,col){\r\n    const colgird=nodes.slice();\r\n    const node=colgird[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      ispath: true,\r\n      //isvisited: false,\r\n    };\r\n    colgird[row][col] = newNode;\r\n    return colgird;\r\n\r\n}\r\n  animateDijkstra(visitedNodesInOrder,path) {\r\n    const {nodes}=this.state;\r\n    for (let i = 0; i <visitedNodesInOrder.length; i++) {\r\n      const node=visitedNodesInOrder[i];\r\n      setTimeout(() => {\r\n        ///the reason for not using these methods is given above\r\n     //const visitedgrid=this.getcoloredvisitedgrid(this.state.nodes,node.row,node.col);\r\n     //this.setState({nodes: visitedgrid});\r\n     //i added these if condition because i dont want to color the starting and finishing node\r\n     if(!((node.row===START_NODE_ROW&&node.col===START_NODE_COL)||node.row===FINISH_NODE_ROW&&node.col===FINISH_NODE_COL))\r\n     document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node visited-node';\r\n          \r\n     if(i==visitedNodesInOrder.length-1){\r\n      this.animateShortestPath(path);\r\n    }\r\n      }, 20*i);\r\n   \r\n    }\r\n  }\r\n  getcoloredvisitedgrid(nodes,row,col){\r\n    const coloredvisitedgrid=nodes.slice();\r\n    const node=coloredvisitedgrid[row][col];\r\n    const newnode = {\r\n      ...node,\r\n      animatevisited: true,\r\n    };\r\n    coloredvisitedgrid[row][col] = newnode;\r\n    return coloredvisitedgrid;\r\n  }\r\n  visualizedfs(){\r\n     // const visitednodedfs=[];\r\n      const {nodes,mouseIsPressed}=this.state;\r\n      const startnode=nodes[START_NODE_ROW][START_NODE_COL];\r\n      const finishnode=nodes[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n     const visitednodedfs=dfs(nodes,startnode,finishnode);\r\n     const path=getpath(finishnode);\r\n      this.animatedfs(visitednodedfs,path);\r\n      \r\n  }\r\n  animatedfs(visitednodedfs,path){\r\n      for(let i=0;i<visitednodedfs.length;i++){\r\n        const node=visitednodedfs[i];\r\n        setTimeout(() => {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node visited-node';\r\n          if(i==visitednodedfs.length-1){\r\n            this.animateShortestPath(path);\r\n          }\r\n        }, 20*i);\r\n      }\r\n  }\r\n  \r\n  render() {\r\n    const { nodes ,mouseIsPressed} = this.state;\r\n\r\n    return (\r\n        <div>\r\n            <button className=\"dijbtn\" onClick={()=>this.visualizeDijkstra()}>Visualize Dijkstra Algorithm!</button>\r\n            <button className=\"dijbtn\" onClick={()=>this.visualizedfs()}>Visualize DFS</button>\r\n            <button className=\"dijbtn\" >Visualize BFS</button>\r\n      <div className=\"grid\">\r\n        {nodes.map((row, rowindx) => {\r\n          return (\r\n            <div className=\"colsetter\" key={rowindx} id={rowindx}>\r\n              {row.map((node, colindx) => {\r\n                  const {row,col,isfinish,isstart,iswall,animatevisited,ispath,isinstack,tempstart,tempfinish}=node;\r\n                return <Node\r\n                key={colindx}\r\n                id={colindx}\r\n                 isfinish={isfinish}\r\n                 isstart={isstart}\r\n                 iswall={iswall}\r\n                 isinstack={isinstack}\r\n                 tempstart={tempstart}\r\n                 tempfinish={tempfinish}\r\n                animatevisited={animatevisited}\r\n                 col={col}\r\n                 row={row}\r\n                 ispath={ispath}\r\n                 ////it is the most difficult task for me calling the event handling\r\n                 mouseIsPressed={mouseIsPressed}\r\n                 onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                 onMouseEnter={(row, col) =>\r\n                   this.handleMouseEnter(row, col)\r\n                 }\r\n                 onMouseUp={(row,col) => this.handleMouseUp(row,col)}\r\n                ></Node>;\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst createNode=(row,col)=> {\r\n    return{\r\n        row,\r\n        col,\r\n        isinstack: false,\r\n        isstart:row===START_NODE_ROW&&col===START_NODE_COL?true:false,\r\n        isfinish:row===FINISH_NODE_ROW&&col===FINISH_NODE_COL?true:false,\r\n        isvisited: false,\r\n        animatevisited:false,\r\n        distance: Infinity,\r\n        tempstart:false,\r\n        tempfinish:false,\r\n        iswall: false,\r\n        prevnode: null,\r\n        ispath: false\r\n    \r\n    }\r\n}\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  console.log(\"called fun\");\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    iswall: !node.iswall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nexport default pathFindingProject;\r\n","import React from 'react';\nimport './App.css';\nimport PathFindingProject from './pathFindingProject/pathFindingProject';\nfunction App() {\n    return (\n      <div className=\"App\">\n        <h1 className=\"title\">hey! Welcome To Path Finding Visualizer</h1>\n        <PathFindingProject></PathFindingProject>\n      </div>\n    );\n  }\nexport default App","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}